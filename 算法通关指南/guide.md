# 解题思路
- 数组不变，区间查询：前缀和、树状数组、线段树；
- 数组单点修改，区间查询：树状数组、线段树；
- 数组区间修改，单点查询：差分、线段树；
- 数组区间修改，区间查询：线段树。

*注意：上述总结是对于一般性而言的（能直接解决的），对标的是模板问题。
但存在经过一些经过“额外”操作，对问题进行转化，从而使用别的解决方案求解的情况。
例如某些问题，我们可以先对原数组进行差分，然后使用树状数组，也能解决区间修改问题。
或者使用多个树状数组来维护多个指标，从而实现类似线段树的持久化标记操作。
但这些不属于一般性，所以就不添加到题解了。*

# 树状数组
**询问**

给你一个数组，如何快速地计算任意一段连续子数组的元素和？

对于一个子数组来说，如果遍历子数组的每个数，把它们加起来，时间复杂度是 O(n)，太慢了。

下标从 left 到 right 的子数组元素和，可以看成是下标从 1 到 right 的子数组元素和，减去下标从 1 到 left−1 的子数组元素和。例如数组 [3,1,4,1,5,9]，子数组 [4,1,5] 的元素和，等于 [3,1,4,1,5] 的元素和，减去 [3,1] 的元素和。

按照这个方法，算出每个前缀 [1,i]（表示下标从 1 到 i 的连续子数组）的元素和，就可以 O(1) 地计算任意连续子数组的元素和了。

**更新**

但是，如果还可以修改数组中的元素呢？

比如我把下标为 1 的元素修改了，由于所有前缀都包含下标 1，那么就需要更新所有前缀的元素和，更新操作就需要 O(n) 的时间，这太慢了。

能不能把前缀 [1,i] 拆分成若干段连续子数组呢？

如果拆分得太细，比如拆分成 [1,1],[2,2],[3,3],⋯，虽然更新是 $O(1)$ 的，但计算子数组元素和还是得遍历累加，时间复杂度是 $O(n)$，太慢了。

平衡

上面的做法，要么询问是 $O(1)$ 更新是 $O(n)$，要么询问是 $O(n)$ 更新是 $O(1)$，时间差距悬殊。

如何「平衡」询问和更新的时间复杂度？

关键在于如何拆分子数组（区间）。

能否把任意前缀拆分成若干个关键区间，使得更新操作也只会更新若干个关键区间？

这样回答询问时，只需要遍历并累加若干个关键区间的元素和。更新元素时，也只需要遍历并更新若干个关键区间的元素和。

![示意图](算法通关指南/image.png)

一般地：

- 如果 i 是 2 的幂，那么 [1,i] 无需拆分。
- 如果 i 不是 2 的幂，那么先拆分出一个最小的 2 的幂，记作 lowbit(i)（例如 6 拆分出 2），得到长为 lowbit(i) 的关键区间 [i−lowbit(i)+1,i]，问题转换成剩下的 [1,i−lowbit(i)] 如何拆分，这是一个规模更小的子问题。
